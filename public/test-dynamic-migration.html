<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Quest Migration Test</title>
    <style>
        body { 
            font-family: 'Consolas', monospace; 
            background: #1a1a1a; 
            color: #e0e0e0; 
            margin: 0; 
            padding: 20px; 
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
            background: #2d2d2d; 
            padding: 20px; 
            border-radius: 8px; 
            margin-bottom: 20px; 
        }
        button { 
            background: #4CAF50; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            border-radius: 4px; 
            cursor: pointer; 
            margin-right: 10px; 
        }
        button:disabled { background: #666; }
        button:hover:not(:disabled) { background: #45a049; }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .info { color: #2196F3; }
        .warning { color: #FF9800; }
        pre { 
            background: #1a1a1a; 
            padding: 15px; 
            border-radius: 4px; 
            overflow-x: auto; 
            max-height: 400px; 
            overflow-y: auto; 
        }
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .comparison-item {
            background: #3d3d3d;
            padding: 15px;
            border-radius: 6px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Dynamic Quest Migration Test</h1>
        <p>Testing the new dynamic quest analysis vs old hardcoded approach</p>
        
        <button onclick="testMigration()" id="testBtn">Test Dynamic Migration</button>
        <button onclick="clearResults()" id="clearBtn">Clear Results</button>
    </div>

    <div class="container">
        <h2>Test Results</h2>
        <div id="testResults">Click "Test Dynamic Migration" to start...</div>
    </div>

    <div class="container">
        <h2>Data Comparison</h2>
        <div class="comparison">
            <div class="comparison-item">
                <h3>Quest Structure</h3>
                <div id="questComparison">No data yet...</div>
            </div>
            <div class="comparison-item">
                <h3>Item Details</h3>
                <div id="itemComparison">No data yet...</div>
            </div>
        </div>
    </div>

    <script>
        let testData = {
            pvpResponse: null,
            pveResponse: null,
            startTime: null,
            endTime: null
        };

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = `[${timestamp}] ${message}`;
            
            const resultsDiv = document.getElementById('testResults');
            const color = type === 'error' ? '#f44336' : type === 'success' ? '#4CAF50' : type === 'warning' ? '#FF9800' : '#2196F3';
            resultsDiv.innerHTML += `<div style="color: ${color}; margin: 5px 0;">${logEntry}</div>`;
            
            console.log(logEntry);
        }

        async function testApiEndpoint(gameMode) {
            log(`üîç Testing ${gameMode.toUpperCase()} mode...`, 'info');
            
            try {
                const startTime = performance.now();
                const response = await fetch(`/api/tarkov-data?gameMode=${gameMode}`);
                const endTime = performance.now();
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const responseTime = endTime - startTime;
                
                log(`‚úÖ ${gameMode.toUpperCase()} API call successful (${responseTime.toFixed(2)}ms)`, 'success');
                log(`   Quest data source: ${data.questDataSource}`, 'info');
                log(`   Quests analyzed: ${data.questsAnalyzed || 'unknown'}`, 'info');
                log(`   Items processed: ${data.itemsProcessed || data.mappedPrices?.length || 'unknown'}`, 'info');
                log(`   Processing time: ${data.totalTime?.toFixed(2)}ms`, 'info');
                
                // Validate response structure
                if (!data.mappedPrices || !Array.isArray(data.mappedPrices)) {
                    throw new Error('Invalid response structure: missing mappedPrices array');
                }
                
                if (!data.pvpPriceCache || !data.pvePriceCache) {
                    throw new Error('Invalid response structure: missing price caches');
                }
                
                log(`   ‚úì Response structure validated`, 'success');
                
                return { data, responseTime, gameMode };
                
            } catch (error) {
                log(`‚ùå ${gameMode.toUpperCase()} API call failed: ${error.message}`, 'error');
                throw error;
            }
        }

        function analyzeQuestData(pvpData, pveData) {
            log('üìä Analyzing quest data...', 'info');
            
            const pvpQuests = groupByQuest(pvpData.mappedPrices);
            const pveQuests = groupByQuest(pveData.mappedPrices);
            
            log(`   PvP Quests found: ${Object.keys(pvpQuests).length}`, 'info');
            log(`   PvE Quests found: ${Object.keys(pveQuests).length}`, 'info');
            
            // Check if quest structures match
            const pvpQuestNames = Object.keys(pvpQuests).sort();
            const pveQuestNames = Object.keys(pveQuests).sort();
            
            if (JSON.stringify(pvpQuestNames) === JSON.stringify(pveQuestNames)) {
                log(`   ‚úì Quest structures match between PvP and PvE`, 'success');
            } else {
                log(`   ‚ö†Ô∏è Quest structures differ between game modes`, 'warning');
            }
            
            // Display quest breakdown
            const questComparison = document.getElementById('questComparison');
            questComparison.innerHTML = '<h4>Quests Found:</h4>';
            
            pvpQuestNames.forEach(questName => {
                const pvpItems = pvpQuests[questName];
                const pveItems = pveQuests[questName] || [];
                
                questComparison.innerHTML += `
                    <div style="margin: 10px 0; padding: 10px; background: #2d2d2d; border-radius: 4px;">
                        <strong>${questName}</strong><br>
                        PvP: ${pvpItems.length} items | PvE: ${pveItems.length} items
                    </div>
                `;
            });
            
            return { pvpQuests, pveQuests };
        }

        function groupByQuest(items) {
            return items.reduce((acc, item) => {
                if (!acc[item.category]) {
                    acc[item.category] = [];
                }
                acc[item.category].push(item);
                return acc;
            }, {});
        }

        function analyzeItemData(pvpData, pveData) {
            log('üì¶ Analyzing item data...', 'info');
            
            const pvpItems = pvpData.mappedPrices;
            const pveItems = pveData.mappedPrices;
            
            // Check for dynamic vs hardcoded detection
            const hasDynamicData = pvpData.questDataSource === 'dynamic';
            log(`   Dynamic quest detection: ${hasDynamicData ? '‚úÖ Active' : '‚ùå Fallback'}`, hasDynamicData ? 'success' : 'warning');
            
            // Count items with acquisition methods
            const pvpItemsWithMethods = pvpItems.filter(item => 
                item.crafts?.length > 0 || item.barters?.length > 0 || item.bundledItem
            );
            const pveItemsWithMethods = pveItems.filter(item => 
                item.crafts?.length > 0 || item.barters?.length > 0 || item.bundledItem
            );
            
            log(`   PvP items with acquisition methods: ${pvpItemsWithMethods.length}/${pvpItems.length}`, 'info');
            log(`   PvE items with acquisition methods: ${pveItemsWithMethods.length}/${pveItems.length}`, 'info');
            
            // Check for price differences
            let priceDifferences = 0;
            pvpItems.forEach(pvpItem => {
                const pveItem = pveItems.find(item => item.id === pvpItem.id);
                if (pveItem && pvpItem.pvpPrice !== pveItem.pvePrice) {
                    priceDifferences++;
                }
            });
            
            log(`   Price differences between modes: ${priceDifferences} items`, 'info');
            
            // Display item comparison
            const itemComparison = document.getElementById('itemComparison');
            itemComparison.innerHTML = '<h4>Sample Items:</h4>';
            
            pvpItems.slice(0, 3).forEach(item => {
                const pveItem = pveItems.find(i => i.id === item.id);
                itemComparison.innerHTML += `
                    <div style="margin: 10px 0; padding: 10px; background: #2d2d2d; border-radius: 4px;">
                        <strong>${item.shortName}</strong><br>
                        PvP: ‚ÇΩ${item.pvpPrice?.toLocaleString() || 0} | 
                        PvE: ‚ÇΩ${pveItem?.pvePrice?.toLocaleString() || 0}<br>
                        Crafts: ${item.crafts?.length || 0} | 
                        Barters: ${item.barters?.length || 0} | 
                        Bundled: ${item.bundledItem ? 'Yes' : 'No'}
                    </div>
                `;
            });
        }

        async function testMigration() {
            try {
                document.getElementById('testBtn').disabled = true;
                document.getElementById('testResults').innerHTML = '';
                
                testData.startTime = Date.now();
                log('üöÄ Starting Dynamic Quest Migration Test', 'info');
                log('This test validates that the new dynamic workflow works correctly', 'info');
                
                // Test both game modes
                const [pvpResult, pveResult] = await Promise.all([
                    testApiEndpoint('pvp'),
                    testApiEndpoint('pve')
                ]);
                
                testData.pvpResponse = pvpResult;
                testData.pveResponse = pveResult;
                testData.endTime = Date.now();
                
                // Analyze the results
                const questAnalysis = analyzeQuestData(pvpResult.data, pveResult.data);
                analyzeItemData(pvpResult.data, pveResult.data);
                
                const totalTime = testData.endTime - testData.startTime;
                log(`‚úÖ Migration test completed successfully in ${totalTime}ms`, 'success');
                log(`üéØ Dynamic quest system is working correctly!`, 'success');
                
            } catch (error) {
                log(`‚ùå Migration test failed: ${error.message}`, 'error');
                console.error('Migration test error:', error);
            } finally {
                document.getElementById('testBtn').disabled = false;
            }
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = 'Click "Test Dynamic Migration" to start...';
            document.getElementById('questComparison').innerHTML = 'No data yet...';
            document.getElementById('itemComparison').innerHTML = 'No data yet...';
            testData = {
                pvpResponse: null,
                pveResponse: null,
                startTime: null,
                endTime: null
            };
        }
    </script>
</body>
</html> 